// Author: Drunkie
// Description: A graphics library for rendering objects in 2D and 3D environments
// Documentation: http://www.wiremod.com/forum/cpu-gpu-hi-speed-discussion-help/26005-zgpu-graphics-library-documentation.html


#define GL 1

// Font enums
#define GL_FONT_LUCIDA_CONSOLE 0
#define GL_FONT_COURIER_NEW 1
#define GL_FONT_TREBUCHET 2
#define GL_FONT_ARIAL 3
#define GL_FONT_TIMES_NEW_ROMAN 4
#define GL_FONT_COOLVETICA 5
#define GL_FONT_AKBAR 6
#define GL_FONT_CSD 7

// Buffer enums
#define GL_BUFFER_FRONT 0
#define GL_BUFFER_BACK 1
#define GL_BUFFER_VERTEX 2

// Coordinate pipe enums
#define GL_CPIPE_DIRECT 0
#define GL_CPIPE_RESOLUTION 1
#define GL_CPIPE_0_1 2
#define GL_CPIPE_N1_1 3
#define GL_CPIPE_N256_256 4

// Vertex pipe enums
#define GL_VPIPE_XY 0
#define GL_VPIPE_YZ 1
#define GL_VPIPE_XZ 2
#define GL_VPIPE_XYZPROJ 3
#define GL_VPIPE_XYTRANSFORM 4
#define GL_VPIPE_XYZTRANSFORM 5

// denable / ddisable enums
#define GL_VERTEX_ZSORT 0
#define GL_VERTEX_LIGHTING 1
#define GL_VERTEX_BUFFER 2
#define GL_VERTEX_CULLING 3
#define GL_VERTEX_DCULLING 4
#define GL_VERTEX_TEXTURING 5

// Fillmode enums
#define GL_FILL_SOLID 0
#define GL_FILL_WIREFRAME 1

// Cullmode enums
#define GL_CULL_FRONT 0
#define GL_CULL_BACK 1

// Lightmode enums
#define GL_LIGHT_FRONT 1
#define GL_LIGHT_BACK -1


// Clear functions
void glClear( float r, float g, float b )
{
    mov #__BG.r,r; mov #__BG.g,g; mov #__BG.b,b; mov #__BG.a,255;
    dclrscr __BG;
}
void glClear4( float r, float g, float b, float a )
{
    mov #__BG.r,r; mov #__BG.g,g; mov #__BG.b,b; mov #__BG.a,a;
    dclrscr __BG;
}
void glClearTexture()
{
    dclrtex;
}
void glHWClear( float num )
{
    mov #regHWClear,num;
}

// Color functions
void glColor( float r, float g, float b )
{
    mov #__FG.r,r; mov #__FG.g,g; mov #__FG.b,b; mov #__FG.a,255;
    dcolor __FG;
}
void glColor4( float r, float g, float b, float a )
{
    mov #__FG.r,r; mov #__FG.g,g; mov #__FG.b,b; mov #__FG.a,a;
    dcolor __FG;
}
void glBrightness( float r, float g, float b, float w )
{
    mov #regBrightnessR,r;
    mov #regBrightnessG,g;
    mov #regBrightnessB,b;
    mov #regBrightnessW,w;
}
void glContrast( float r, float g, float b, float w )
{
    mov #regContrastR,r;
    mov #regContrastG,g;
    mov #regContrastB,b;
    mov #regContrastW,w;
}

// Texture functions
void glSetTexture( char* texname )
{
    dxtexture texname;
}
void glTexture( float texid )
{
    dtexture texid;
}
void glTextureSize( float num )
{
    mov #regTexSize,num;
}
void glTextureDataPtr( float num )
{
    mov #regTexDataPtr,num;
}
void glTextureDataSize( float num )
{
    mov #regTexDataSz,num;
}
void glTextureRotation( float num )
{
    mov #regTexRotation,num;
}
void glTextureScale( float num )
{
    mov #regTexScale,num;
}
void glTextureCenterUV( float u, float v )
{
    mov #regTexCenterU,u;
    mov #regTexCenterV,v;
}
void glTextureOffsetUV( float u, float v )
{
    mov #regTexOffsetU,u;
    mov #regTexOffsetV,v;
}

// Frame functions
void glSleep( float milliseconds )
{
    timer #__CURTIME; 
    sub #__CURTIME,#__TIMESTAMP;
    if (*__CURTIME <= (milliseconds / 1000)) {
        mov #regHWClear,0;
        jmp glExit;
    }
    timer #__TIMESTAMP;   
}
void glExit()
{
    dexit;
}

// Pipeline functions
void glCoordPipe( float coordpipe )
{
    dcpipe coordpipe;
}
void glVertexPipe( float vertexpipe )
{
    dvxpipe vertexpipe;
}

// Hardware functions
void glReset( float num )
{
    mov #regReset,num;
}
void glHalt( float num )
{
    mov #regHalt,num;
}
void glRAMReset( float num )
{
    mov #regRAMReset,num;
}
void glHScale( float num )
{
    mov #regHScale,num;
}
void glVScale( float num )
{
    mov #regVScale,num;
}
void glHWScale( float num )
{
    mov #regHWScale,num;
}
void glHWRotate( float num )
{
    mov #regRotation,num;
}

// Offset functions
void glOffset( float x, float y )
{
    mov #__V1.x,x; mov #__V1.y,y;
    dmove __V1;
}
float glOffsetX()
{
    return *regOffsetX;
}
float glOffsetY()
{
    return *regOffsetY;
}
void glCenter( float x, float y )
{
    mov #regCenterX,x;
    mov #regCenterY,y;
}

// Async functions
void glAsyncReset( float num )
{
    mov #regAsyncReset,num;
}
void glAsyncClk( float num )
{
    mov #regAsyncClk,num;
}
void glAsyncFreq( float num )
{
    mov #regAsyncFreq,num;
}
void glEntryPoint( float idx, float ptr )
{
    dentrypoint idx,ptr;
}
void glBegin()
{
    dbegin;
}
void glEnd()
{
    dend;
}

// Cursor functions
void glCursor( float num )
{
    mov #regCursor,num;
}
float glCursorX()
{
    return *regCursorX;
}
float glCursorY()
{
    return *regCursorY;
}
float glCursorButtons()
{
    return *regCursorButtons;
}

// Circle functions
void glCircleQuality( float num )
{
    mov #regCircleQuality,num;
}
void glCircleStart( float num )
{
    mov #regCircleStart,num;
}
void glCircleEnd( float num )
{
    mov #regCircleEnd,num;
}

// Screen scaling functions
void glScreenScale( float num )
{
    mov #regScale,num;
}
void glScreenScaleX( float x )
{
    mov #regScaleX,x;
}
void glScreenScaleY( float y )
{
    mov #regScaleY,y;
}

// 2D graphics functions
void glCircle( float posx, float posy, float radius )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dcircle __V1,radius;
}
void glRect( float posx, float posy, float destx, float desty )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    mov #__V2.x,destx; mov #__V2.y,desty;
    drect __V1,__V2;
}
void glRectWH( float posx, float posy, float sizex, float sizey )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    mov #__V2.x,sizex; mov #__V2.y,sizey;
    drectwh __V1,__V2;
}
void glORect( float posx, float posy, float destx, float desty )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    mov #__V2.x,destx; mov #__V2.y,desty;
    dorect __V1,__V2;
}
void glORectWH( float posx, float posy, float sizex, float sizey )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    mov #__V2.x,sizex; mov #__V2.y,sizey;
    dorectwh __V1,__V2;
}
void glPixel( float posx, float posy )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dpixel __V1,__FG;
}
void glLine( float posx, float posy, float destx, float desty )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    mov #__V2.x,destx; mov #__V2.y,desty;
    dline __V1,__V2;
}
void glPoly2D( float* vertexdata, float vertexcount )
{
    dvxdata_2f vertexdata,vertexcount;
}
void glLineWidth( float linewidth )
{
    dsetwidth linewidth;
}

// Text functions
void glFont( float fontid )
{
    dsetfont fontid;
}
void glFontHAlign( float num )
{
    mov #regFontHalign,num;
}
void glFontVAlign( float num )
{
    mov #regFontValign,num;
}
void glFontSize( float fontsize )
{
    dsetsize fontsize;
}
float glTextWidth( char* text )
{
    preserve eax;
    dtextwidth eax,text;
    return eax;
}
float glTextHeight( char* text )
{
    preserve eax;
    dtextheight eax,text;
    return eax;
}
void glWriteString( float posx, float posy, char* text )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dwrite __V1,text;
}
void glWriteFloat( float posx, float posy, float num )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dwritef __V1,num;
}
void glWriteInt( float posx, float posy, float num )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dwritei __V1,num;
}
void glWriteFmt( float posx, float posy, char* text )
{
    mov #__V1.x,posx; mov #__V1.y,posy;
    dwritefmt __V1,text;
}
float glParamList()
{
    return *regParamList;
}

// 3D graphics functions
void glPoly3D( float* vertexbuffer, float facecount )
{
    if (*__MUPDATE == 1)
    {
        *__MUPDATE == 0;
        mrotate __MROTATEMATRIX,__VROTATE;
        mtranslate __MTRANSLATEMATRIX,__VTRANSLATE;
        mscale __MSCALEMATRIX,__VSCALE;
        mmov __MMODELMATRIX,__MTRANSLATEMATRIX;
        mmul __MMODELMATRIX,__MROTATEMATRIX;
        mmul __MMODELMATRIX,__MSCALEMATRIX;
        mmov __MMODELVIEWMATRIX,__MVIEWMATRIX;
        mmul __MMODELVIEWMATRIX,__MMODELMATRIX;
        mload __MMODELVIEWMATRIX; 
        mloadproj __MPROJECTIONMATRIX;
    }
    
    if (*__FILLMODE == GL_FILL_SOLID)
        dvxdata_3f vertexbuffer,facecount;
    else if (*__FILLMODE == GL_FILL_WIREFRAME)
        dvxdata_3f_wf vertexbuffer,facecount;
}
void glFlush()
{
    dvxflush;
}
void glEnable( float num )
{
    denable num;
}
void glDisable( float num )
{
    ddisable num;
}
void glLightPos( float x, float y, float z )
{
    mov #__LIGHTPOS.x,x; mov #__LIGHTPOS.y,y; mov #__LIGHTPOS.z,z;
    dsetlight 0,__LIGHTDATA;
}
void glLightColor( float r, float g, float b, float brightness )
{
    mov #__LIGHTCOL.r,r; mov #__LIGHTCOL.g,g;
    mov #__LIGHTCOL.b,b; mov #__LIGHTCOL.a,brightness;
    dsetlight 0,__LIGHTDATA;
}
void glFillMode( float fmode )
{
    mov #__FILLMODE,fmode;
}
void glLookAt( float posx, float posy, float posz, float targx, float targy, float targz, float upx, float upy, float upz )
{
    mov #__VLOOKAT_POS.x,posx; mov #__VLOOKAT_POS.y,posy; mov #__VLOOKAT_POS.z,posz;
    mov #__VLOOKAT_TARG.x,targx; mov #__VLOOKAT_TARG.y,targy; mov #__VLOOKAT_TARG.z,targz;
    mov #__VLOOKAT_UP.x,upx; mov #__VLOOKAT_UP.y,upy; mov #__VLOOKAT_UP.z,upz;
    mlookat __MVIEWMATRIX,__VLOOKAT;
    *__MUPDATE = 1;
}
void glPerspective( float fov, float asp, float znear, float zfar )
{
    mov #__VPERSPECTIVE.x,fov; mov #__VPERSPECTIVE.y,asp;
    mov #__VPERSPECTIVE.z,znear; mov #__VPERSPECTIVE.w,zfar;
    mperspective __MPROJECTIONMATRIX,__VPERSPECTIVE;
    *__MUPDATE = 1;
}
void glRotate( float x, float y, float z, float w )
{
    mov #__VROTATE.x,x; mov #__VROTATE.y,y; mov #__VROTATE.z,z; mov #__VROTATE.w,w;      
    *__MUPDATE = 1;
}
void glTranslate( float x, float y, float z )
{
    mov #__VTRANSLATE.x,x; mov #__VTRANSLATE.y,y; mov #__VTRANSLATE.z,z;
    *__MUPDATE = 1;
}
void glScale( float x, float y, float z )
{
    mov #__VSCALE.x,x; mov #__VSCALE.y,y; mov #__VSCALE.z,z;
    *__MUPDATE = 1;
}
void glZOffset( float num )
{
    mov #regZOffset,num;
}
void glCullDistance( float num )
{
    mov #regCullDistance,num;
}
void glCullMode( float num )
{
    mov #regCullMode,num;
}
void glLightMode( float num )
{
    mov #regLightMode,num;
}
void glVertexArray( float num )
{
    mov #regVertexArray,num;
}

// Other functions
void glVertexMode( float num )
{
    mov #regVertexMode,num;
}
void glSetRenderTarget( float num )
{
    if (num == GL_BUFFER_FRONT)
        dsetbuf_fbo;
    else if (num == GL_BUFFER_BACK)
        dsetbuf_spr;
    else if (num == GL_BUFFER_VERTEX)
        dsetbuf_vx;
}
float glIndex()
{
    return *regIndex;
}


// Global-scope variables
color __FG,255,255,255;
color __BG;
vec4f __V1;
vec4f __V2;

alloc __TIMESTAMP;
alloc __CURTIME;
alloc __FILLMODE;

__LIGHTDATA:
vec4f __LIGHTPOS,0,0,-5;
color __LIGHTCOL,255,255,255,1;

__VLOOKAT:
vec3f __VLOOKAT_POS,0,0,-5;
vec3f __VLOOKAT_TARG,0,0,0;
vec3f __VLOOKAT_UP,0,1,0;

matrix __MROTATEMATRIX;
matrix __MTRANSLATEMATRIX;
matrix __MSCALEMATRIX;
matrix __MPROJECTIONMATRIX;
matrix __MVIEWMATRIX;
matrix __MMODELMATRIX;
matrix __MMODELVIEWMATRIX;
alloc __MUPDATE,1;

vec4f __VROTATE;
vec4f __VTRANSLATE;
vec4f __VPERSPECTIVE;
vec4f __VSCALE,1,1,1,0;
